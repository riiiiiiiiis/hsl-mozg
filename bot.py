import sqlite3
import logging
import sys
from datetime import datetime
import asyncio
import urllib.request
import urllib.error
import config
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.constants import ParseMode # Import ParseMode
from telegram.error import Conflict
from telegram.ext import (
    Application,
    ApplicationBuilder,
    CommandHandler,
    CallbackQueryHandler,
    ContextTypes,
    PicklePersistence,
    MessageHandler,
    filters,
)

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Dedicated logger for course selections
course_selection_logger = logging.getLogger('course_selection')
course_selection_logger.setLevel(logging.INFO)
# Create a file handler for the course selection logger
course_log_handler = logging.FileHandler('course_selection.log')
course_log_handler.setLevel(logging.INFO)
# Create a formatter and set it for the handler
course_log_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
course_log_handler.setFormatter(course_log_formatter)
# Add the handler to the logger
course_selection_logger.addHandler(course_log_handler)
course_selection_logger.propagate = False # Prevent logging to root logger as well

BOOKING_DURATION_NOTICE = "–í–∞—à–µ –º–µ—Å—Ç–æ –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–æ –Ω–∞ 1 —á–∞—Å. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–∏–∑–≤–µ–¥–∏—Ç–µ –æ–ø–ª–∞—Ç—É –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ —á–µ–∫–∞ –≤ —ç—Ç–æ—Ç —á–∞—Ç –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è."

COURSES = [
    {
        "id": "1",
        "button_text": "–í–∞–π–± –ö–æ–¥–∏–Ω–≥",
        "name": "–í–∞–π–± –∫–æ–¥–∏–Ω–≥",
        "price_usd": 70,
        "description": "–ù–∞ —ç—Ç–æ–º –∫—É—Ä—Å–µ –≤ —Ç–µ—á–µ–Ω–∏–µ –¥–≤—É—Ö –Ω–µ–¥–µ–ª—å —è —É—á—É –ø—Ä–µ–≤—Ä–∞—â–∞—Ç—å –∏–¥–µ–∏ –≤ —Ä–∞–±–æ—á–∏–µ –ø—Ä–æ—Ç–æ—Ç–∏–ø—ã. –ü—Ä–æ–≥—Ä–∞–º–º–∏—Ä—É–µ–º –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ. –ù–∞–≥–ª—è–¥–Ω–æ –æ–±—ä—è—Å–Ω—è—é –∫–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç –ò–ò, –∏–Ω—Ç–µ—Ä–Ω–µ—Ç –∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è. –û–±—â–µ–Ω–∏–µ –≤ –∑–∞–∫—Ä—ã—Ç–æ–π –≥—Ä—É–ø–ø–µ, –¥–æ–º–∞—à–∫–∏, —Ç—Ä–∏ —Å–æ–∑–≤–æ–Ω–∞ —Å –∑–∞–ø–∏—Å—è–º–∏. –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è –º–µ—Å—è—Ü –ø–æ—Å–ª–µ –∫—É—Ä—Å–∞.\n–ü–æ—Å–ª–µ –æ–±—É—á–µ–Ω–∏—è —Ç—ã –±—É–¥–µ—à—å –∑–Ω–∞—Ç—å –∫–∞–∫ —Å–æ–∑–¥–∞–≤–∞—Ç—å —Å–∞–π—Ç—ã —Å –ø–æ–º–æ—â—å—é –ò–ò, —á—Ç–æ —Ç–∞–∫–æ–µ –±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö, –∫–∞–∫ —Å–æ–±—Ä–∞—Ç—å —Ç–µ–ª–µ–≥—Ä–∞–º –±–æ—Ç–∞ –∑–∞ –≤–µ—á–µ—Ä –∏ –≤—ã–ª–æ–∂–∏—Ç—å –ø—Ä–æ–µ–∫—Ç –≤ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç. –ù–∞–±–æ—Ä –ø—Ä–æ–º–ø—Ç–æ–≤ –≤ –ø–æ–¥–∞—Ä–æ–∫!\n–î–ª—è –∫–æ–≥–æ: –≤–æ–æ–±—â–µ –¥–ª—è –≤—Å–µ—Ö\n–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: –¥–≤–µ –Ω–µ–¥–µ–ª–∏\n–§–æ—Ä–º–∞—Ç: 2 –¥–≤—É—Ö—á–∞—Å–æ–≤—ã—Ö —Å–æ–∑–≤–æ–Ω–∞ –ø–æ —Å—Ä–µ–¥–∞–º –≤ 20:00 –ú–°–ö\n–°—Ç–æ–∏–º–æ—Å—Ç—å: 70$\n–°—Ç–∞—Ä—Ç: 28 –º–∞—è\n\n–û–ø–ª–∞—Ç–∞ –≤–æ–∑–º–æ–∂–Ω–∞ –ø–µ—Ä–µ–≤–æ–¥–æ–º –Ω–∞ –∫–∞—Ä—Ç—ã –¢-–ë–∞–Ω–∫–∞, –ö–∞—Å–ø–∏ –∏–ª–∏ –≤ USDT –Ω–∞ –∫—Ä–∏–ø—Ç–æ –∫–æ—à–µ–ª–µ–∫.\n\n–ß—Ç–æ –¥–∞–ª—å—à–µ: –ü–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã —è –¥–æ–±–∞–≤–ª—é —Ç–µ–±—è –≤ –∑–∞–∫—Ä—ã—Ç—É—é –≥—Ä—É–ø–ø—É, –≥–¥–µ –º—ã –±—É–¥–µ–º –æ–±—â–∞—Ç—å—Å—è –∏ –¥–µ–ª–∏—Ç—å—Å—è –º–∞—Ç–µ—Ä–∏–∞–ª–∞–º–∏. –ü–µ—Ä–µ–¥ —Å—Ç–∞—Ä—Ç–æ–º –∫—É—Ä—Å–∞ –ø—Ä–∏—à–ª—é –≤—Å—é –Ω–µ–æ–±—Ö–æ–¥–∏–º—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é."
    },
    {
        "id": "3",
        "button_text": "–ë–ª–æ–∫—á–µ–π–Ω –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏—è",
        "name": "–ë–ª–æ–∫—á–µ–π–Ω (—Ä–∞–∑–æ–≤–∞—è –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏—è)",
        "price_usd": 25,
        "description": "–ö–∞–∫ –∑–∞–≤–µ—Å—Ç–∏ –∫—Ä–∏–ø—Ç–æ –∫–æ—à–µ–ª–µ–∫, –ø–æ–ø–æ–ª–Ω–∏—Ç—å –µ–≥–æ, —Å–ø—É—Å—Ç–∏—Ç—å –Ω–∞ –º–µ–º–∫–æ–∏–Ω—ã —á–µ—Ä–µ–∑ –¥–µ—Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –±–∏—Ä–∂–∏, —Å–¥–µ–ª–∞—Ç—å –º–µ–º–∫–æ–∏–Ω –ø—Ä–æ —Å–≤–æ–µ–≥–æ –∫–æ—Ç–∞, –∞ –ø–æ—Ç–æ–º –æ–±–Ω–∞–ª–∏—á–∏—Ç—å –º–∏–ª–ª–∏–æ–Ω.\n–î–ª—è –∫–æ–≥–æ: –¥–ª—è —ç–Ω—Ç—É–∑–∏–∞—Å—Ç–æ–≤ –Ω–æ–≤–æ–π —Ü–∏—Ñ—Ä–æ–≤–æ–π —ç–∫–æ–Ω–æ–º–∏–∫–∏\n–§–æ—Ä–º–∞—Ç: –ø–æ–ª—É—Ç–æ—Ä–∞—á–∞—Å–æ–≤–æ–µ –æ–Ω–ª–∞–π–Ω –∑–∞–Ω—è—Ç–∏–µ –≤ —É–¥–æ–±–Ω–æ–µ –¥–ª—è —Ç–µ–±—è –≤—Ä–µ–º—è\n–°—Ç–æ–∏–º–æ—Å—Ç—å: 25$\n\n–û–ø–ª–∞—Ç–∞ –≤–æ–∑–º–æ–∂–Ω–∞ –ø–µ—Ä–µ–≤–æ–¥–æ–º –Ω–∞ –∫–∞—Ä—Ç—ã –¢-–ë–∞–Ω–∫–∞, –ö–∞—Å–ø–∏ –∏–ª–∏ –≤ USDT –Ω–∞ –∫—Ä–∏–ø—Ç–æ –∫–æ—à–µ–ª–µ–∫."
    },
    {
        "id": "4",
        "button_text": "ChatGPT –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏—è",
        "name": "ChatGPT (—Ä–∞–∑–æ–≤–∞—è –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏—è)",
        "price_usd": 25,
        "description": "–ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤–µ–ª–∏—á–∞–π—à–µ–µ –∏–∑–æ–±—Ä–µ—Ç–µ–Ω–∏–µ —á–µ–ª–æ–≤–µ—á–µ—Å—Ç–≤–∞ –Ω–∞ —Å—Ç–æ –ø—Ä–æ—Ü–µ–Ω—Ç–æ–≤.\n–î–ª—è –∫–æ–≥–æ: –¥–ª—è –≤—Å–µ—Ö\n–§–æ—Ä–º–∞—Ç: –ø–æ–ª—É—Ç–æ—Ä–∞—á–∞—Å–æ–≤–æ–µ –æ–Ω–ª–∞–π–Ω –∑–∞–Ω—è—Ç–∏–µ –≤ —É–¥–æ–±–Ω–æ–µ –¥–ª—è —Ç–µ–±—è –≤—Ä–µ–º—è\n–°—Ç–æ–∏–º–æ—Å—Ç—å: 25$\n\n–û–ø–ª–∞—Ç–∞ –≤–æ–∑–º–æ–∂–Ω–∞ –ø–µ—Ä–µ–≤–æ–¥–æ–º –Ω–∞ –∫–∞—Ä—Ç—ã –¢-–ë–∞–Ω–∫–∞, –ö–∞—Å–ø–∏ –∏–ª–∏ –≤ USDT –Ω–∞ –∫—Ä–∏–ø—Ç–æ –∫–æ—à–µ–ª–µ–∫."
    }
]

# Constants for calendar link and other URLs
CALENDAR_LINK = "https://calendar.app.google/gYhZNcreyWrAuEgT9"

# Callback constants for course selection correspond to course 'id' or index
CALLBACK_RESERVE_SPOT = "reserve_spot"
CALLBACK_SELECT_COURSE_PREFIX = "select_course_" # Used to identify course selection callbacks
# Individual callbacks like CALLBACK_SELECT_COURSE_1 are still used for clarity in button creation if needed
# but logic will parse ID from callback string like "select_course_1", "select_course_2" etc.
CALLBACK_SELECT_COURSE_1 = "select_course_1"
CALLBACK_SELECT_COURSE_2 = "select_course_2"
CALLBACK_SELECT_COURSE_3 = "select_course_3"
CALLBACK_SELECT_COURSE_4 = "select_course_4"
CALLBACK_CONFIRM_COURSE_SELECTION = "confirm_course_selection_v2"
CALLBACK_BACK_TO_COURSE_SELECTION = "back_to_course_selection"
CALLBACK_ADMIN_APPROVE_PAYMENT = "admin_approve_"
CALLBACK_ADMIN_REJECT_PAYMENT = "admin_reject_"
CALLBACK_CANCEL_RESERVATION = "cancel_reservation"

def escape_markdown_v2(text: str) -> str:
    """Helper function to escape text for MarkdownV2 parsing."""
    escape_chars = r'_*[]()~`>#+-=|{}.!'
    return "".join(f'\\{char}' if char in escape_chars else char for char in str(text))


def get_db_connection():
    conn = sqlite3.connect(config.DB_NAME)
    conn.row_factory = sqlite3.Row
    try:
        # Check if the course_id column exists
        cursor = conn.cursor()
        cursor.execute("PRAGMA table_info(bookings)")
        columns = [column[1] for column in cursor.fetchall()]
        
        if 'course_id' not in columns:
            # Add course_id column if it doesn't exist
            conn.execute("ALTER TABLE bookings ADD COLUMN course_id TEXT")
            logger.info("Added course_id column to bookings table")
        
        # Create table if it doesn't exist
        conn.execute("""
            CREATE TABLE IF NOT EXISTS bookings (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                username TEXT,
                first_name TEXT,
                chosen_course TEXT,
                course_id TEXT,
                confirmed INTEGER DEFAULT 0,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(user_id, chosen_course, created_at)
            )
        """)
        conn.commit()
    except sqlite3.Error as e:
        logger.error(f"Database table creation/check error: {e}")
    return conn

def get_course_selection_keyboard() -> InlineKeyboardMarkup:
    keyboard = []
    for course in COURSES:
        keyboard.append([InlineKeyboardButton(course["button_text"], callback_data=f"{CALLBACK_SELECT_COURSE_PREFIX}{course['id']}")])
    return InlineKeyboardMarkup(keyboard)

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [[InlineKeyboardButton("–ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∫—É—Ä—Å—ã", callback_data=CALLBACK_RESERVE_SPOT)]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    try:
        if update.message:
            await update.message.reply_text(
                "–ü—Ä–∏–≤–µ—Ç! –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ —à–∫–æ–ª—É HashSlash! üëã\n\n"
                "–ú–µ–Ω—è –∑–æ–≤—É—Ç –°–µ—Ä–µ–∂–∞, –∏ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 10 –ª–µ—Ç —è –ø–æ–º–æ–≥–∞—é –ª—é–¥—è–º –æ—Å–≤–∞–∏–≤–∞—Ç—å —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –∏ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏.\n\n"
                "–°–µ–π—á–∞—Å —è –æ—Ç–∫—Ä—ã–ª –Ω–∞–±–æ—Ä –≤ –≥—Ä—É–ø–ø—É –ø–æ –≤–∞–π–±–∫–æ–¥–∏–Ω–≥—É. –í–∞–π–±–∫–æ–¥–∏–Ω–≥ ‚Äì —ç—Ç–æ –Ω–æ–≤—ã–π —Å–ø–æ—Å–æ–± —Å–æ–∑–¥–∞–≤–∞—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –∏ —Å–∞–π—Ç—ã, –Ω–µ —Ç—Ä–∞—Ç—è –≥–æ–¥—ã –Ω–∞ –∏–∑—É—á–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è.\n\n"
                "–ü—Ä–µ–¥—Å—Ç–∞–≤—å—Ç–µ: –≤—ã –ø—Ä–æ—Å—Ç–æ —Ä–∞—Å—Å–∫–∞–∑—ã–≤–∞–µ—Ç–µ –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω–æ–º—É –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É (–ò–ò) –Ω–∞ –æ–±—ã—á–Ω–æ–º —è–∑—ã–∫–µ, –∫–∞–∫–∏–º –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –≤–∞—à–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∏–ª–∏ —Å–∞–π—Ç, –∞ –æ–Ω —Å–∞–º —Å–æ–∑–¥–∞—ë—Ç –≤—Å—ë –∑–∞ –≤–∞—Å.\n\n"
                "–í—ã ‚Äì –∫–∞–∫ —Ä–µ–∂–∏—Å—Å—ë—Ä, –∫–æ—Ç–æ—Ä—ã–π –∑–∞–¥–∞—ë—Ç –∏–¥–µ—é –∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ. –í–∞–º –Ω–µ –Ω—É–∂–Ω–æ —Ä–∞–∑–±–∏—Ä–∞—Ç—å—Å—è –≤ –∫–æ–¥–µ –∏–ª–∏ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏—Ö –¥–µ—Ç–∞–ª—è—Ö ‚Äì –≤—ã —Å–æ—Å—Ä–µ–¥–æ—Ç–∞—á–∏–≤–∞–µ—Ç–µ—Å—å –Ω–∞ —Ç–æ–º, —á—Ç–æ –¥–µ–ª–∞–µ—Ç –≤–∞—à –ø—Ä–æ–¥—É–∫—Ç –∫—Ä—É—Ç—ã–º: –µ–≥–æ –¥–∏–∑–∞–π–Ω, —É–¥–æ–±—Å—Ç–≤–æ –∏ —Ü–µ–Ω–Ω–æ—Å—Ç—å –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.\n\n"
                "–í–∞–π–±–∫–æ–¥–∏–Ω–≥ –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç —Ä–∞–∑—Ä–∞–±–æ—Ç–∫—É –¥–ª—è –≤—Å–µ—Ö, –∫—Ç–æ —Ö–æ—á–µ—Ç –≤–æ–ø–ª–æ—Ç–∏—Ç—å —Å–≤–æ–∏ –∏–¥–µ–∏, –¥–∞–∂–µ –±–µ–∑ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏—Ö –Ω–∞–≤—ã–∫–æ–≤.",
                reply_markup=reply_markup
            )
    except Exception as e:
        logger.error(f"Error in start_command: {e}", exc_info=True)

async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    if not query or not query.data:
        if query: await query.answer()
        return

    try:
        await query.answer()
    except Exception as e:
        logger.error(f"Error answering callback query for data '{query.data}': {e}", exc_info=True)

    user = query.from_user
    user_id = user.id
    username = user.username or ""
    first_name = user.first_name or "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å"

    context.user_data['user_id'] = user_id
    context.user_data['username'] = username
    context.user_data['first_name'] = first_name

    if query.data == CALLBACK_RESERVE_SPOT or query.data == CALLBACK_BACK_TO_COURSE_SELECTION:
        reply_markup = get_course_selection_keyboard()
        message_text = "–°–≤–æ–±–æ–¥–Ω–∞—è –∫–∞—Å—Å–∞! –°–µ–∑–æ–Ω 2025 –ª–µ—Ç–æ, –æ—Ç–∫—Ä—ã—Ç—ã –∫—É—Ä—Å—ã –¥–ª—è –∑–∞–ø–∏—Å–∏.\n\n–Ø –ø—Ä–æ–≤–æ–∂—É –≥—Ä—É–ø–ø–æ–≤—ã–µ –∫—É—Ä—Å—ã –∏ –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–µ –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏–∏ –ø–æ —Ä–∞–∑–ª–∏—á–Ω—ã–º —Ç–µ–º–∞–º. –°–µ–π—á–∞—Å —è –Ω–∞–±–∏—Ä–∞—é –≥—Ä—É–ø–ø—É –Ω–∞ –∫—É—Ä—Å –ø–æ –≤–∞–π–±–∫–æ–¥–∏–Ω–≥—É, –∞ —Ç–∞–∫–∂–µ –¥–æ—Å—Ç—É–ø–Ω—ã –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–µ –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏–∏ –ø–æ –¥—Ä—É–≥–∏–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è–º. –í—ã–±–µ—Ä–∏—Ç–µ –∏–Ω—Ç–µ—Ä–µ—Å—É—é—â–∏–π –≤–∞—Å –≤–∞—Ä–∏–∞–Ω—Ç:"
        try:
            await query.edit_message_text(text=message_text, reply_markup=reply_markup)
        except Exception as e:
            logger.error(f"Error editing message for {query.data}: {e}", exc_info=True)

    elif query.data.startswith(CALLBACK_SELECT_COURSE_PREFIX):
        selected_course_id = query.data.replace(CALLBACK_SELECT_COURSE_PREFIX, "")
        selected_course = next((course for course in COURSES if course["id"] == selected_course_id), None)

        if not selected_course:
            logger.warning(f"User {user_id} selected an invalid course ID: {selected_course_id}")
            try:
                await query.edit_message_text(text="–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∫—É—Ä—Å –∑–∞–Ω–æ–≤–æ.", reply_markup=get_course_selection_keyboard())
            except Exception as e_corr:
                logger.error(f"Error sending correction message for invalid course ID: {e_corr}", exc_info=True)
            return

        chosen_course_name = selected_course["name"]
        course_description = selected_course["description"]
        course_price_usd = selected_course["price_usd"]

        # Log course selection
        try:
            log_message = (
                f"UserID: {user_id} - Username: {username} - FirstName: {first_name} - "
                f"CourseID: {selected_course_id} - CourseName: {chosen_course_name}"
            )
            course_selection_logger.info(log_message)
        except Exception as log_e:
            logger.error(f"Failed to log course selection for user {user_id} (Course: {selected_course_id}): {log_e}", exc_info=True)

        context.user_data['pending_course_choice'] = chosen_course_name
        context.user_data['pending_course_id'] = selected_course_id
        context.user_data['pending_course_price_usd'] = course_price_usd
        
        escaped_course_name = escape_markdown_v2(chosen_course_name)
        escaped_first_name = escape_markdown_v2(first_name)
        escaped_course_description = escape_markdown_v2(course_description)

        message_text = (
            f"–í—ã –≤—ã–±—Ä–∞–ª–∏ –∫—É—Ä—Å: *{escaped_course_name}*\n"
            f"–ò–º—è: *{escaped_first_name}*\n\n"
            f"*{escaped_course_description}*\n\n"
            "–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç–µ —Å–≤–æ–π –≤—ã–±–æ—Ä –¥–ª—è –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–≥–æ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è?"
        )
        keyboard = [
            [InlineKeyboardButton("‚úÖ –î–∞, –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å", callback_data=CALLBACK_CONFIRM_COURSE_SELECTION)],
            [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥ (–∫ –≤—ã–±–æ—Ä—É –∫—É—Ä—Å–∞)", callback_data=CALLBACK_BACK_TO_COURSE_SELECTION)],
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        try:
            await query.edit_message_text(text=message_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN_V2)
        except Exception as e:
            logger.error(f"Error editing message for course selection confirmation: {e}", exc_info=True)
    
    elif query.data == CALLBACK_CONFIRM_COURSE_SELECTION:
        current_user_id = context.user_data.get('user_id', user_id)
        current_username = context.user_data.get('username', username)
        current_first_name = context.user_data.get('first_name', first_name)
        chosen_course_name = context.user_data.get('pending_course_choice')
        course_id = context.user_data.get('pending_course_id')
        course_price_usd_val = context.user_data.get('pending_course_price_usd') # Renamed to avoid conflict

        if not chosen_course_name or course_price_usd_val is None:
            logger.warning(f"User {current_user_id} tried to confirm course, but 'pending_course_choice' or 'pending_course_price_usd' not found.")
            try:
                await query.edit_message_text(text="–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∫—É—Ä—Å –∑–∞–Ω–æ–≤–æ.", reply_markup=get_course_selection_keyboard())
            except Exception as e_corr:
                logger.error(f"Error sending correction message: {e_corr}", exc_info=True)
            return

        conn = None
        booking_id = None
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute(
                """INSERT INTO bookings (user_id, username, first_name, chosen_course, course_id, confirmed)
                   VALUES (?, ?, ?, ?, ?, 0)""",
                (current_user_id, current_username, current_first_name, chosen_course_name, course_id)
            )
            booking_id = cursor.lastrowid
            conn.commit()
            logger.info(f"Preliminary booking ID {booking_id} for user {current_user_id} ({current_first_name}), course '{chosen_course_name}' saved (status 0).")

            context.user_data[f'booking_id_{current_user_id}'] = booking_id

            # Calculate payment amounts
            price_kzt = round(course_price_usd_val * config.USD_TO_KZT_RATE, 2)
            price_rub = round(course_price_usd_val * config.USD_TO_RUB_RATE, 2)
            price_ars = round(course_price_usd_val * config.USD_TO_ARS_RATE, 2)

            # Escaping dynamic parts for MarkdownV2
            esc_chosen_course_name = escape_markdown_v2(chosen_course_name)
            esc_booking_id = escape_markdown_v2(str(booking_id))
            esc_booking_duration_notice = escape_markdown_v2(BOOKING_DURATION_NOTICE)

            esc_tbank_card_number = escape_markdown_v2(config.TBANK_CARD_NUMBER)
            esc_tbank_card_holder = escape_markdown_v2(config.TBANK_CARD_HOLDER)
            esc_price_rub = escape_markdown_v2(f"{price_rub:.2f} RUB")

            esc_kaspi_card_number = escape_markdown_v2(config.KASPI_CARD_NUMBER)
            esc_price_kzt = escape_markdown_v2(f"{price_kzt:.2f} KZT")

            esc_ars_alias = escape_markdown_v2(config.ARS_ALIAS)
            esc_price_ars = escape_markdown_v2(f"{price_ars:.2f} ARS")
            
            esc_usdt_address = escape_markdown_v2(config.USDT_TRC20_ADDRESS)
            esc_price_usdt = escape_markdown_v2(f"{course_price_usd_val:.2f} USDT") 
            esc_crypto_network = escape_markdown_v2(config.CRYPTO_NETWORK)
            esc_binance_id = escape_markdown_v2(config.BINANCE_ID)

            message_text = (
                f"üìù –í–∞—à–µ –º–µ—Å—Ç–æ –Ω–∞ –∫—É—Ä—Å '*{esc_chosen_course_name}*' –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–æ \(–ó–∞—è–≤–∫–∞ ‚Ññ*{esc_booking_id}*\)\.\n\n" 
                f"‚è≥ _{esc_booking_duration_notice}_\n\n" 
                f"üí≥ *–†–µ–∫–≤–∏–∑–∏—Ç—ã –¥–ª—è –æ–ø–ª–∞—Ç—ã:*\n\n" 
                f"*üá∑üá∫ –¢\-–ë–∞–Ω–∫ \(RUB\):*\n" 
                f"–ö–∞—Ä—Ç–∞: `{esc_tbank_card_number}`\n" 
                f"–ü–æ–ª—É—á–∞—Ç–µ–ª—å: {esc_tbank_card_holder}\n" 
                f"–°—É–º–º–∞: `{esc_price_rub}`\n\n" 
                f"*üá∞üáø Kaspi \(KZT\):*\n" 
                f"–ö–∞—Ä—Ç–∞: `{esc_kaspi_card_number}`\n" 
                f"–°—É–º–º–∞: `{esc_price_kzt}`\n\n" 
                f"*üá¶üá∑ –ê—Ä–≥–µ–Ω—Ç–∏–Ω—Å–∫–æ–µ –ü–µ—Å–æ \(ARS\):*\n" 
                f"Alias: `{esc_ars_alias}`\n" 
                f"–°—É–º–º–∞: `{esc_price_ars}`\n\n" 
                f"*üí∏ –ö—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–∞ \(USDT TRC\-20\):*\n"
                f"–ê–¥—Ä–µ—Å: `{esc_usdt_address}`\n" 
                f"–°–µ—Ç—å: {esc_crypto_network}\n" 
                f"–°—É–º–º–∞: `{esc_price_usdt}`\n" 
                f"–í—ã —Ç–∞–∫–∂–µ –º–æ–∂–µ—Ç–µ –æ–ø–ª–∞—Ç–∏—Ç—å –ø–æ Binance ID: `{esc_binance_id}`\n\n" 
                f"_–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –±—É–¥—å—Ç–µ –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω—ã –ø—Ä–∏ –≤—ã–±–æ—Ä–µ —Å–µ—Ç–∏ –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞ USDT\._\n\n" 
                f"üßæ –ü–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ —á–µ–∫–∞ –ø—Ä—è–º–æ –≤ —ç—Ç–æ—Ç —á–∞—Ç\."
            )

            keyboard_payment = [
                [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∏—Ç—å –±—Ä–æ–Ω—å", callback_data=f"{CALLBACK_CANCEL_RESERVATION}_{booking_id}")]
            ]
            reply_markup_payment = InlineKeyboardMarkup(keyboard_payment)

            await query.edit_message_text(text=message_text, reply_markup=reply_markup_payment, parse_mode=ParseMode.MARKDOWN_V2)

            # Don't clear pending_course_choice, pending_course_id, pending_course_price_usd here.
            # They are needed if the user cancels immediately after this message.
            # They will be cleared upon successful payment confirmation by admin or by explicit cancellation.
        except sqlite3.IntegrityError:
             logger.warning(f"User {current_user_id} might have tried to book the same course again too quickly.")
             await query.edit_message_text(text="–í—ã —É–∂–µ –ø–æ–¥–∞–ª–∏ –∑–∞—è–≤–∫—É –Ω–∞ —ç—Ç–æ—Ç –∫—É—Ä—Å. –û–∂–∏–¥–∞–π—Ç–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –∏–ª–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –Ω–∞–º–∏.", reply_markup=None)
        except sqlite3.Error as e_db:
            logger.error(f"Database error for user {current_user_id}: {e_db}", exc_info=True)
            await query.edit_message_text(text="‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
        except Exception as e_gen:
            logger.error(f"Unexpected error for user {current_user_id}: {e_gen}", exc_info=True)
            await query.edit_message_text(text="‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞.")
        finally:
            if conn:
                conn.close()

    elif query.data.startswith(CALLBACK_CANCEL_RESERVATION):
        parts = query.data.split('_')
        try:
            booking_id_to_cancel = int(parts[-1])
        except (IndexError, ValueError):
            logger.error(f"Invalid cancel reservation callback data: {query.data}")
            await query.edit_message_text("–û—à–∏–±–∫–∞: –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ—Ç–º–µ–Ω—ã.")
            return

        current_user_id = context.user_data.get('user_id', user_id)
        
        conn = None
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            # Update booking status to cancelled (e.g., confirmed = -1)
            # We only cancel if it's in state 0 (pending payment)
            cursor.execute(
                "UPDATE bookings SET confirmed = -1 WHERE id = ? AND user_id = ? AND confirmed = 0", 
                (booking_id_to_cancel, current_user_id)
            )
            if cursor.rowcount > 0:
                conn.commit()
                logger.info(f"User {current_user_id} cancelled booking ID {booking_id_to_cancel}.")
                
                # Clean up user_data related to this booking
                if context.user_data.get(f'booking_id_{current_user_id}') == booking_id_to_cancel:
                    del context.user_data[f'booking_id_{current_user_id}']
                if 'pending_course_choice' in context.user_data:
                    del context.user_data['pending_course_choice']
                if 'pending_course_id' in context.user_data:
                    del context.user_data['pending_course_id']
                if 'pending_course_price_usd' in context.user_data:
                    del context.user_data['pending_course_price_usd']

                message_text = "–í–∞—à–µ –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–µ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ."
                reply_markup = InlineKeyboardMarkup([[InlineKeyboardButton("–í—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥–æ–π –∫—É—Ä—Å", callback_data=CALLBACK_BACK_TO_COURSE_SELECTION)]])
                await query.edit_message_text(text=message_text, reply_markup=reply_markup)
            else:
                logger.warning(f"User {current_user_id} tried to cancel booking ID {booking_id_to_cancel}, but it was not found or not in a cancellable state (confirmed=0).")
                await query.edit_message_text(text="–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–º–µ–Ω–∏—Ç—å –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ. –í–æ–∑–º–æ–∂–Ω–æ, –æ–Ω–æ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ –∏–ª–∏ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
        
        except sqlite3.Error as e_db:
            logger.error(f"DB error during cancellation for booking {booking_id_to_cancel}: {e_db}", exc_info=True)
            await query.edit_message_text("–û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –æ—Ç–º–µ–Ω–µ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è.")
        except Exception as e:
            logger.error(f"Error during cancellation for booking {booking_id_to_cancel}: {e}", exc_info=True)
            await query.edit_message_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–º–µ–Ω–µ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è.")
        finally:
            if conn:
                conn.close()

    elif query.data.startswith(CALLBACK_ADMIN_APPROVE_PAYMENT):
        parts = query.data.split('_')
        try:
            target_user_id = int(parts[-2])
            booking_id_to_approve = int(parts[-1])
        except (IndexError, ValueError):
            logger.error(f"Invalid admin approval callback data: {query.data}")
            await query.edit_message_text("–û—à–∏–±–∫–∞: –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.")
            return

        conn = None
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute(
                "UPDATE bookings SET confirmed = 2 WHERE id = ? AND user_id = ? AND confirmed = 1",
                (booking_id_to_approve, target_user_id)
            )
            if cursor.rowcount > 0:
                conn.commit()
                logger.info(f"Admin {user_id} approved payment for booking ID {booking_id_to_approve}, user {target_user_id}.")
                
                esc_booking_id_approved = escape_markdown_v2(str(booking_id_to_approve))
                esc_target_user_id = escape_markdown_v2(str(target_user_id))

                await query.edit_message_text(
                    f"‚úÖ –û–ø–ª–∞—Ç–∞ –¥–ª—è –∑–∞—è–≤–∫–∏ ‚Ññ*{esc_booking_id_approved}* \(–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å *{esc_target_user_id}*\) –ü–û–î–¢–í–ï–†–ñ–î–ï–ù–ê\.",
                    parse_mode=ParseMode.MARKDOWN_V2
                )
                
                # Get course details to check if it's a consultation
                cursor.execute(
                    "SELECT chosen_course, course_id FROM bookings WHERE id = ?",
                    (booking_id_to_approve,)
                )
                booking_details = cursor.fetchone()
                
                if booking_details:
                    chosen_course = booking_details[0]
                    course_id = booking_details[1]
                    
                    # Check if this is a consultation (ids 3 and 4 are consultations)
                    is_consultation = course_id in ["3", "4"]
                    
                    if is_consultation:
                        # For consultations, send message with calendar link
                        esc_calendar_link = escape_markdown_v2(CALENDAR_LINK)
                        esc_chosen_course = escape_markdown_v2(chosen_course)
                        
                        await context.bot.send_message(
                            chat_id=target_user_id,
                            text=f"üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º\! –í–∞—à–∞ –æ–ø–ª–∞—Ç–∞ –∑–∞ –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏—é *{esc_chosen_course}* \(–∑–∞—è–≤–∫–∞ ‚Ññ*{esc_booking_id_approved}*\) –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞\!\n\n"
                                 f"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —É–¥–æ–±–Ω–æ–µ –¥–ª—è –≤–∞—Å –≤—Ä–µ–º—è –¥–ª—è –ø—Ä–æ–≤–µ–¥–µ–Ω–∏—è –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏–∏ –ø–æ —Å—Å—ã–ª–∫–µ:\n"
                                 f"{esc_calendar_link}",
                            parse_mode=ParseMode.MARKDOWN_V2
                        )
                    else:
                        # For regular courses, send standard confirmation
                        await context.bot.send_message(
                            chat_id=target_user_id,
                            text=f"üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º\! –í–∞—à–∞ –æ–ø–ª–∞—Ç–∞ –ø–æ –∑–∞—è–≤–∫–µ ‚Ññ*{esc_booking_id_approved}* –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞\. –ú–µ—Å—Ç–æ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–æ\!",
                            parse_mode=ParseMode.MARKDOWN_V2
                        )
                else:
                    # Fallback if booking details not found
                    await context.bot.send_message(
                        chat_id=target_user_id,
                        text=f"üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º\! –í–∞—à–∞ –æ–ø–ª–∞—Ç–∞ –ø–æ –∑–∞—è–≤–∫–µ ‚Ññ*{esc_booking_id_approved}* –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞\.",
                        parse_mode=ParseMode.MARKDOWN_V2
                    )
            else:
                logger.warning(f"Admin {user_id} tried to approve booking ID {booking_id_to_approve} for user {target_user_id}, but no matching pending record found or already processed.")
                await query.edit_message_text(f"‚ö†Ô∏è –ó–∞—è–≤–∫–∞ ‚Ññ{booking_id_to_approve} (–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {target_user_id}) –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∏–ª–∏ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞.")
        except sqlite3.Error as e_db:
            logger.error(f"DB error during admin approval: {e_db}", exc_info=True)
            await query.edit_message_text("–û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–∏.")
        except Exception as e:
            logger.error(f"Error during admin approval: {e}", exc_info=True)
            await query.edit_message_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–∏.")
        finally:
            if conn:
                conn.close()
    else:
        logger.warning(f"Received unknown callback_data: {query.data} from user {user_id} ({first_name})")

async def photo_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message or not update.message.photo:
        return

    user = update.message.from_user
    user_id = user.id
    first_name = user.first_name or "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å"
    
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute(
            "SELECT id, chosen_course FROM bookings WHERE user_id = ? AND confirmed = 0 ORDER BY created_at DESC LIMIT 1",
            (user_id,)
        )
        booking_record = cursor.fetchone()

        if booking_record:
            booking_id = booking_record['id']
            chosen_course = booking_record['chosen_course']
            
            cursor.execute("UPDATE bookings SET confirmed = 1 WHERE id = ?", (booking_id,))
            conn.commit()
            logger.info(f"Photo received for booking ID {booking_id} from user {user_id}. Status updated to 1.")

            esc_first_name = escape_markdown_v2(first_name)
            esc_booking_id = escape_markdown_v2(str(booking_id))
            esc_chosen_course = escape_markdown_v2(chosen_course)
            esc_admin_contact = escape_markdown_v2(config.ADMIN_CONTACT)


            await update.message.reply_text(
                f"üôè –°–ø–∞—Å–∏–±–æ, {esc_first_name}\! –í–∞—à–µ —Ñ–æ—Ç–æ –¥–ª—è –∑–∞—è–≤–∫–∏ ‚Ññ*{esc_booking_id}* \(–∫—É—Ä—Å '*{esc_chosen_course}*' \) –ø–æ–ª—É—á–µ–Ω–æ\.\n"
                f"–û–ø–ª–∞—Ç–∞ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è\. –ú—ã —Å–æ–æ–±—â–∏–º –≤–∞–º –æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ\.\n"
                f"–ï—Å–ª–∏ –≤–æ–∑–Ω–∏–∫–Ω—É—Ç –≤–æ–ø—Ä–æ—Å—ã, —Å–≤—è–∂–∏—Ç–µ—Å—å —Å {esc_admin_contact}\.",
                parse_mode=ParseMode.MARKDOWN_V2
            )

            if config.TARGET_CHAT_ID == 0: 
                 logger.error("TARGET_CHAT_ID is not set. Cannot forward photo to admin chat.")
                 await update.message.reply_text("–ù–µ —É–¥–∞–ª–æ—Å—å —É–≤–µ–¥–æ–º–∏—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π.")
                 return
            
            esc_user_username = escape_markdown_v2(user.username or 'N/A')

            caption_for_admin = (
                f"üßæ *–ù–æ–≤—ã–π —á–µ–∫ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏\!*\n"
                f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {esc_first_name} \(ID: `{user_id}`\, @{esc_user_username}\)\n"
                f"–ó–∞—è–≤–∫–∞ ‚Ññ: *{esc_booking_id}*\n"
                f"–ö—É—Ä—Å: *{esc_chosen_course}*"
            )
            
            forwarded_message = await context.bot.forward_message(
                chat_id=config.TARGET_CHAT_ID,
                from_chat_id=update.message.chat_id,
                message_id=update.message.message_id
            )
            
            admin_keyboard = [
                [InlineKeyboardButton(f"‚úÖ –û–¥–æ–±—Ä–∏—Ç—å (–ó–∞—è–≤–∫–∞ {booking_id})", callback_data=f"{CALLBACK_ADMIN_APPROVE_PAYMENT}{user_id}_{booking_id}")],
            ]
            admin_reply_markup = InlineKeyboardMarkup(admin_keyboard)
            await context.bot.send_message(
                chat_id=config.TARGET_CHAT_ID,
                text=caption_for_admin, 
                reply_markup=admin_reply_markup,
                reply_to_message_id=forwarded_message.message_id if forwarded_message else None,
                parse_mode=ParseMode.MARKDOWN_V2
            )

        else:
            logger.info(f"Photo received from user {user_id}, but no active booking (status 0) found.")
            await update.message.reply_text(
                "–°–ø–∞—Å–∏–±–æ –∑–∞ —Ñ–æ—Ç–æ! –ù–µ –º–æ–≥—É –Ω–∞–π—Ç–∏ –∞–∫—Ç–∏–≤–Ω—É—é –∑–∞—è–≤–∫—É –¥–ª—è –≤–∞—Å. –ï—Å–ª–∏ –≤—ã –Ω–µ–¥–∞–≤–Ω–æ –≤—ã–±–∏—Ä–∞–ª–∏ –∫—É—Ä—Å, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π."
            )

    except sqlite3.Error as e_db:
        logger.error(f"DB error in photo_handler for user {user_id}: {e_db}", exc_info=True)
        await update.message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–µ–≥–æ —Ñ–æ—Ç–æ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
    except Exception as e:
        logger.error(f"Error in photo_handler for user {user_id}: {e}", exc_info=True)
        await update.message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–æ—Ç–æ.")
    finally:
        if conn:
            conn.close()


async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    logger.error(f"Exception while handling an update: {context.error}", exc_info=context.error)
    if isinstance(context.error, Conflict):
        logger.critical(
            "TELEGRAM CONFLICT ERROR DETECTED. "
            "This means another instance of the bot is running with the same token. "
            "Please ensure only ONE instance is active."
        )

async def post_initialization(application: Application) -> None:
    logger.info("Running post-initialization: Attempting to delete webhook...")
    bot_token = application.bot.token
    if not bot_token:
        logger.error("Bot token not found in application object.")
        return

    webhook_delete_url = f"https://api.telegram.org/bot{bot_token}/deleteWebhook?drop_pending_updates=true"
    try:
        with urllib.request.urlopen(webhook_delete_url, timeout=10) as response:
            response_body = response.read().decode()
            logger.info(f"Webhook deletion API response: {response_body}")
            if '"ok":true' not in response_body.lower():
                logger.warning("Webhook deletion might not have been successful.")
    except urllib.error.URLError as e:
        logger.error(f"URLError while trying to delete webhook: {e.reason}")
    except Exception as e:
        logger.error(f"Unexpected error during webhook deletion: {e}", exc_info=True)
    await asyncio.sleep(2)

def main() -> None:
    logger.info("Starting bot application setup...")
    persistence = PicklePersistence(filepath=config.PERSISTENCE_FILEPATH)
    application = (
        ApplicationBuilder()
        .token(config.BOT_TOKEN)
        .post_init(post_initialization)
        .persistence(persistence)
        .build()
    )
    application.add_handler(CommandHandler("start", start_command))
    application.add_handler(CallbackQueryHandler(button_callback))
    application.add_handler(MessageHandler(filters.PHOTO & ~filters.COMMAND, photo_handler))
    application.add_error_handler(error_handler)
    
    logger.info("Bot starting to poll for updates...")
    application.run_polling(
        allowed_updates=Update.ALL_TYPES,
        drop_pending_updates=True
    )
    logger.info("Bot application has stopped.")

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        logger.critical(f"Critical error during bot startup: {e}", exc_info=True)
        sys.exit(1)
