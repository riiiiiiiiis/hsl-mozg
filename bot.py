import sqlite3
import logging
import sys
import asyncio
import urllib.request
import urllib.error
import config
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.constants import ParseMode # Import ParseMode
from telegram.error import Conflict
from telegram.ext import (
    Application,
    ApplicationBuilder,
    CommandHandler,
    CallbackQueryHandler,
    ContextTypes,
    PicklePersistence,
    MessageHandler,
    filters,
)

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

BOOKING_DURATION_NOTICE = "–í–∞—à–µ –º–µ—Å—Ç–æ –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–æ –Ω–∞ 1 —á–∞—Å. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–∏–∑–≤–µ–¥–∏—Ç–µ –æ–ø–ª–∞—Ç—É –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ —á–µ–∫–∞ –≤ —ç—Ç–æ—Ç —á–∞—Ç –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è."


COURSE_NAME = "–í–∞–π–± –ö–æ–¥–∏–Ω–≥"
COURSE_DATE_1 = "01.07.2025"
COURSE_DATE_2 = "15.07.2025"
COURSE_DESCRIPTION_TEST = "–≠—Ç–æ –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω—ã–π –∫—É—Ä—Å, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–º–æ–∂–µ—Ç –≤–∞–º –ø–æ–≥—Ä—É–∑–∏—Ç—å—Å—è –≤ –º–∏—Ä —Å–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è, –æ—Å–≤–æ–∏—Ç—å –∫–ª—é—á–µ–≤—ã–µ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏ –∏ —Å–æ–∑–¥–∞—Ç—å —Å–≤–æ–π –ø–µ—Ä–≤—ã–π –ø—Ä–æ–µ–∫—Ç. –ú—ã —Å—Ñ–æ–∫—É—Å–∏—Ä—É–µ–º—Å—è –Ω–∞ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏—Ö –Ω–∞–≤—ã–∫–∞—Ö –∏ –∞–∫—Ç—É–∞–ª—å–Ω—ã—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞—Ö."


COURSE_1_TEXT = f"{COURSE_NAME} ({COURSE_DATE_1})"
COURSE_2_TEXT = f"{COURSE_NAME} ({COURSE_DATE_2})"

CALLBACK_RESERVE_SPOT = "reserve_spot"
CALLBACK_SELECT_COURSE_1 = "select_course_1"
CALLBACK_SELECT_COURSE_2 = "select_course_2"
CALLBACK_CONFIRM_COURSE_SELECTION = "confirm_course_selection_v2"
CALLBACK_BACK_TO_COURSE_SELECTION = "back_to_course_selection"
CALLBACK_ADMIN_APPROVE_PAYMENT = "admin_approve_"
CALLBACK_ADMIN_REJECT_PAYMENT = "admin_reject_"

def escape_markdown_v2(text: str) -> str:
    """Helper function to escape text for MarkdownV2 parsing."""
    escape_chars = r'_*[]()~`>#+-=|{}.!'
    return "".join(f'\\{char}' if char in escape_chars else char for char in str(text))


def get_db_connection():
    conn = sqlite3.connect(config.DB_NAME)
    conn.row_factory = sqlite3.Row
    try:
        conn.execute("""
            CREATE TABLE IF NOT EXISTS bookings (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                username TEXT,
                first_name TEXT,
                chosen_course TEXT,
                confirmed INTEGER DEFAULT 0,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(user_id, chosen_course, created_at)
            )
        """)
        conn.commit()
    except sqlite3.Error as e:
        logger.error(f"Database table creation/check error: {e}")
    return conn

def get_course_selection_keyboard() -> InlineKeyboardMarkup:
    keyboard = [
        [InlineKeyboardButton(COURSE_1_TEXT, callback_data=CALLBACK_SELECT_COURSE_1)],
        [InlineKeyboardButton(COURSE_2_TEXT, callback_data=CALLBACK_SELECT_COURSE_2)],
    ]
    return InlineKeyboardMarkup(keyboard)

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [[InlineKeyboardButton("–ó–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å –º–µ—Å—Ç–æ", callback_data=CALLBACK_RESERVE_SPOT)]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    try:
        if update.message:
            await update.message.reply_text(
                "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å –º–µ—Å—Ç–æ:",
                reply_markup=reply_markup
            )
    except Exception as e:
        logger.error(f"Error in start_command: {e}", exc_info=True)

async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    if not query or not query.data:
        if query: await query.answer()
        return

    try:
        await query.answer()
    except Exception as e:
        logger.error(f"Error answering callback query for data '{query.data}': {e}", exc_info=True)

    user = query.from_user
    user_id = user.id
    username = user.username or ""
    first_name = user.first_name or "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å"

    context.user_data['user_id'] = user_id
    context.user_data['username'] = username
    context.user_data['first_name'] = first_name

    if query.data == CALLBACK_RESERVE_SPOT or query.data == CALLBACK_BACK_TO_COURSE_SELECTION:
        reply_markup = get_course_selection_keyboard()
        message_text = "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –æ–¥–∏–Ω –∏–∑ –∫—É—Ä—Å–æ–≤:"
        try:
            await query.edit_message_text(text=message_text, reply_markup=reply_markup)
        except Exception as e:
            logger.error(f"Error editing message for {query.data}: {e}", exc_info=True)

    elif query.data == CALLBACK_SELECT_COURSE_1 or query.data == CALLBACK_SELECT_COURSE_2:
        chosen_course_text = COURSE_1_TEXT if query.data == CALLBACK_SELECT_COURSE_1 else COURSE_2_TEXT
        context.user_data['pending_course_choice'] = chosen_course_text
        
        escaped_course_text = escape_markdown_v2(chosen_course_text)
        escaped_first_name = escape_markdown_v2(first_name)
        escaped_course_description = escape_markdown_v2(COURSE_DESCRIPTION_TEST)


        message_text = (
            f"–í—ã –≤—ã–±—Ä–∞–ª–∏ –∫—É—Ä—Å: *{escaped_course_text}*\n"
            f"–ò–º—è: *{escaped_first_name}*\n\n"
            f"*{escaped_course_description}*\n\n" # Test course description
            "–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç–µ —Å–≤–æ–π –≤—ã–±–æ—Ä –¥–ª—è –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–≥–æ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è?"
        )
        keyboard = [
            [InlineKeyboardButton("‚úÖ –î–∞, –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å", callback_data=CALLBACK_CONFIRM_COURSE_SELECTION)],
            [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥ (–∫ –≤—ã–±–æ—Ä—É –∫—É—Ä—Å–∞)", callback_data=CALLBACK_BACK_TO_COURSE_SELECTION)],
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        try:
            await query.edit_message_text(text=message_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN_V2)
        except Exception as e:
            logger.error(f"Error editing message for course selection confirmation: {e}", exc_info=True)
    
    elif query.data == CALLBACK_CONFIRM_COURSE_SELECTION:
        current_user_id = context.user_data.get('user_id', user_id)
        current_username = context.user_data.get('username', username)
        current_first_name = context.user_data.get('first_name', first_name)
        chosen_course = context.user_data.get('pending_course_choice')

        if not chosen_course:
            logger.warning(f"User {current_user_id} tried to confirm course, but 'pending_course_choice' not found.")
            try:
                await query.edit_message_text(text="–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∫—É—Ä—Å –∑–∞–Ω–æ–≤–æ.", reply_markup=get_course_selection_keyboard())
            except Exception as e_corr:
                logger.error(f"Error sending correction message: {e_corr}", exc_info=True)
            return

        conn = None
        booking_id = None
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute(
                """INSERT INTO bookings (user_id, username, first_name, chosen_course, confirmed)
                   VALUES (?, ?, ?, ?, 0)""",
                (current_user_id, current_username, current_first_name, chosen_course)
            )
            booking_id = cursor.lastrowid
            conn.commit()
            logger.info(f"Preliminary booking ID {booking_id} for user {current_user_id} ({current_first_name}), course '{chosen_course}' saved (status 0).")

            context.user_data[f'booking_id_{current_user_id}'] = booking_id

            # Escaping dynamic parts for MarkdownV2
            esc_chosen_course = escape_markdown_v2(chosen_course)
            esc_booking_id = escape_markdown_v2(str(booking_id))
            esc_booking_duration_notice = escape_markdown_v2(BOOKING_DURATION_NOTICE)
            
            esc_card_details = escape_markdown_v2(config.CARD_PAYMENT_DETAILS)
            esc_card_amount = escape_markdown_v2(config.CARD_PAYMENT_AMOUNT)
            
            crypto_wallet_md = f"`{config.CRYPTO_WALLET_ADDRESS}`" # Backticks for inline code, no need to escape address itself here
            esc_crypto_amount = escape_markdown_v2(config.CRYPTO_PAYMENT_AMOUNT)
            esc_crypto_network = escape_markdown_v2(config.CRYPTO_NETWORK) # CRYPTO_NETWORK might contain '-'


            message_text = (
                f"üìù –í–∞—à–µ –º–µ—Å—Ç–æ –Ω–∞ –∫—É—Ä—Å '*{esc_chosen_course}*' –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–æ \(–ó–∞—è–≤–∫–∞ ‚Ññ*{esc_booking_id}*\)\.\n\n"
                f"‚è≥ _{esc_booking_duration_notice}_\n\n"
                f"üí≥ *–†–µ–∫–≤–∏–∑–∏—Ç—ã –¥–ª—è –æ–ø–ª–∞—Ç—ã:*\n\n"
                f"*–ö–∞—Ä—Ç–∞:*\n"
                f"{esc_card_details}\n"
                f"–°—É–º–º–∞: `{esc_card_amount}`\n\n"
                f"*–ö—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–∞ \(USDT TRC\\-20\):*\n" # Escaped hyphen in TRC-20
                f"–ö–æ—à–µ–ª–µ–∫: {crypto_wallet_md}\n"
                f"–°—É–º–º–∞: `{esc_crypto_amount}`\n"
                f"–°–µ—Ç—å: {esc_crypto_network}\n\n" # esc_crypto_network will handle escaping for "TRC-20 (Tron)"
                f"_–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –±—É–¥—å—Ç–µ –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω—ã –ø—Ä–∏ –≤—ã–±–æ—Ä–µ —Å–µ—Ç–∏ –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞ USDT\._\n\n"
                f"üßæ –ü–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ —á–µ–∫–∞ –ø—Ä—è–º–æ –≤ —ç—Ç–æ—Ç —á–∞—Ç\."
            )

            await query.edit_message_text(text=message_text, reply_markup=None, parse_mode=ParseMode.MARKDOWN_V2)

            if 'pending_course_choice' in context.user_data:
                del context.user_data['pending_course_choice']
        except sqlite3.IntegrityError:
             logger.warning(f"User {current_user_id} might have tried to book the same course again too quickly.")
             await query.edit_message_text(text="–í—ã —É–∂–µ –ø–æ–¥–∞–ª–∏ –∑–∞—è–≤–∫—É –Ω–∞ —ç—Ç–æ—Ç –∫—É—Ä—Å. –û–∂–∏–¥–∞–π—Ç–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –∏–ª–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –Ω–∞–º–∏.", reply_markup=None)
        except sqlite3.Error as e_db:
            logger.error(f"Database error for user {current_user_id}: {e_db}", exc_info=True)
            await query.edit_message_text(text="‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
        except Exception as e_gen:
            logger.error(f"Unexpected error for user {current_user_id}: {e_gen}", exc_info=True)
            await query.edit_message_text(text="‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞.")
        finally:
            if conn:
                conn.close()

    elif query.data.startswith(CALLBACK_ADMIN_APPROVE_PAYMENT):
        parts = query.data.split('_')
        try:
            target_user_id = int(parts[-2])
            booking_id_to_approve = int(parts[-1])
        except (IndexError, ValueError):
            logger.error(f"Invalid admin approval callback data: {query.data}")
            await query.edit_message_text("–û—à–∏–±–∫–∞: –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.")
            return

        conn = None
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute(
                "UPDATE bookings SET confirmed = 2 WHERE id = ? AND user_id = ? AND confirmed = 1",
                (booking_id_to_approve, target_user_id)
            )
            if cursor.rowcount > 0:
                conn.commit()
                logger.info(f"Admin {user_id} approved payment for booking ID {booking_id_to_approve}, user {target_user_id}.")
                
                esc_booking_id_approved = escape_markdown_v2(str(booking_id_to_approve))
                esc_target_user_id = escape_markdown_v2(str(target_user_id))

                await query.edit_message_text(
                    f"‚úÖ –û–ø–ª–∞—Ç–∞ –¥–ª—è –∑–∞—è–≤–∫–∏ ‚Ññ*{esc_booking_id_approved}* \(–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å *{esc_target_user_id}*\) –ü–û–î–¢–í–ï–†–ñ–î–ï–ù–ê\.",
                    parse_mode=ParseMode.MARKDOWN_V2
                )
                await context.bot.send_message(
                    chat_id=target_user_id,
                    text=f"üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º\! –í–∞—à–∞ –æ–ø–ª–∞—Ç–∞ –ø–æ –∑–∞—è–≤–∫–µ ‚Ññ*{esc_booking_id_approved}* –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞\. –ú–µ—Å—Ç–æ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–æ\!",
                    parse_mode=ParseMode.MARKDOWN_V2
                )
            else:
                logger.warning(f"Admin {user_id} tried to approve booking ID {booking_id_to_approve} for user {target_user_id}, but no matching pending record found or already processed.")
                await query.edit_message_text(f"‚ö†Ô∏è –ó–∞—è–≤–∫–∞ ‚Ññ{booking_id_to_approve} (–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {target_user_id}) –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∏–ª–∏ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞.")
        except sqlite3.Error as e_db:
            logger.error(f"DB error during admin approval: {e_db}", exc_info=True)
            await query.edit_message_text("–û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–∏.")
        except Exception as e:
            logger.error(f"Error during admin approval: {e}", exc_info=True)
            await query.edit_message_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–∏.")
        finally:
            if conn:
                conn.close()
    else:
        logger.warning(f"Received unknown callback_data: {query.data} from user {user_id} ({first_name})")

async def photo_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message or not update.message.photo:
        return

    user = update.message.from_user
    user_id = user.id
    first_name = user.first_name or "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å"
    
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute(
            "SELECT id, chosen_course FROM bookings WHERE user_id = ? AND confirmed = 0 ORDER BY created_at DESC LIMIT 1",
            (user_id,)
        )
        booking_record = cursor.fetchone()

        if booking_record:
            booking_id = booking_record['id']
            chosen_course = booking_record['chosen_course']
            
            cursor.execute("UPDATE bookings SET confirmed = 1 WHERE id = ?", (booking_id,))
            conn.commit()
            logger.info(f"Photo received for booking ID {booking_id} from user {user_id}. Status updated to 1.")

            esc_first_name = escape_markdown_v2(first_name)
            esc_booking_id = escape_markdown_v2(str(booking_id))
            esc_chosen_course = escape_markdown_v2(chosen_course)
            esc_admin_contact = escape_markdown_v2(config.ADMIN_CONTACT)


            await update.message.reply_text(
                f"üôè –°–ø–∞—Å–∏–±–æ, {esc_first_name}\! –í–∞—à–µ —Ñ–æ—Ç–æ –¥–ª—è –∑–∞—è–≤–∫–∏ ‚Ññ*{esc_booking_id}* \(–∫—É—Ä—Å '*{esc_chosen_course}*' \) –ø–æ–ª—É—á–µ–Ω–æ\.\n"
                f"–û–ø–ª–∞—Ç–∞ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è\. –ú—ã —Å–æ–æ–±—â–∏–º –≤–∞–º –æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ\.\n"
                f"–ï—Å–ª–∏ –≤–æ–∑–Ω–∏–∫–Ω—É—Ç –≤–æ–ø—Ä–æ—Å—ã, —Å–≤—è–∂–∏—Ç–µ—Å—å —Å {esc_admin_contact}\.",
                parse_mode=ParseMode.MARKDOWN_V2
            )

            if config.TARGET_CHAT_ID == 0: 
                 logger.error("TARGET_CHAT_ID is not set. Cannot forward photo to admin chat.")
                 await update.message.reply_text("–ù–µ —É–¥–∞–ª–æ—Å—å —É–≤–µ–¥–æ–º–∏—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π.")
                 return
            
            esc_user_username = escape_markdown_v2(user.username or 'N/A')

            caption_for_admin = (
                f"üßæ *–ù–æ–≤—ã–π —á–µ–∫ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏\!*\n"
                f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {esc_first_name} \(ID: `{user_id}`\, @{esc_user_username}\)\n"
                f"–ó–∞—è–≤–∫–∞ ‚Ññ: *{esc_booking_id}*\n"
                f"–ö—É—Ä—Å: *{esc_chosen_course}*"
            )
            
            forwarded_message = await context.bot.forward_message(
                chat_id=config.TARGET_CHAT_ID,
                from_chat_id=update.message.chat_id,
                message_id=update.message.message_id
            )
            
            admin_keyboard = [
                [InlineKeyboardButton(f"‚úÖ –û–¥–æ–±—Ä–∏—Ç—å (–ó–∞—è–≤–∫–∞ {booking_id})", callback_data=f"{CALLBACK_ADMIN_APPROVE_PAYMENT}{user_id}_{booking_id}")],
            ]
            admin_reply_markup = InlineKeyboardMarkup(admin_keyboard)
            await context.bot.send_message(
                chat_id=config.TARGET_CHAT_ID,
                text=caption_for_admin, 
                reply_markup=admin_reply_markup,
                reply_to_message_id=forwarded_message.message_id if forwarded_message else None,
                parse_mode=ParseMode.MARKDOWN_V2
            )

        else:
            logger.info(f"Photo received from user {user_id}, but no active booking (status 0) found.")
            await update.message.reply_text(
                "–°–ø–∞—Å–∏–±–æ –∑–∞ —Ñ–æ—Ç–æ! –ù–µ –º–æ–≥—É –Ω–∞–π—Ç–∏ –∞–∫—Ç–∏–≤–Ω—É—é –∑–∞—è–≤–∫—É –¥–ª—è –≤–∞—Å. –ï—Å–ª–∏ –≤—ã –Ω–µ–¥–∞–≤–Ω–æ –≤—ã–±–∏—Ä–∞–ª–∏ –∫—É—Ä—Å, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π."
            )

    except sqlite3.Error as e_db:
        logger.error(f"DB error in photo_handler for user {user_id}: {e_db}", exc_info=True)
        await update.message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–µ–≥–æ —Ñ–æ—Ç–æ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
    except Exception as e:
        logger.error(f"Error in photo_handler for user {user_id}: {e}", exc_info=True)
        await update.message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–æ—Ç–æ.")
    finally:
        if conn:
            conn.close()


async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    logger.error(f"Exception while handling an update: {context.error}", exc_info=context.error)
    if isinstance(context.error, Conflict):
        logger.critical(
            "TELEGRAM CONFLICT ERROR DETECTED. "
            "This means another instance of the bot is running with the same token. "
            "Please ensure only ONE instance is active."
        )

async def post_initialization(application: Application) -> None:
    logger.info("Running post-initialization: Attempting to delete webhook...")
    bot_token = application.bot.token
    if not bot_token:
        logger.error("Bot token not found in application object.")
        return

    webhook_delete_url = f"https://api.telegram.org/bot{bot_token}/deleteWebhook?drop_pending_updates=true"
    try:
        with urllib.request.urlopen(webhook_delete_url, timeout=10) as response:
            response_body = response.read().decode()
            logger.info(f"Webhook deletion API response: {response_body}")
            if '"ok":true' not in response_body.lower():
                logger.warning("Webhook deletion might not have been successful.")
    except urllib.error.URLError as e:
        logger.error(f"URLError while trying to delete webhook: {e.reason}")
    except Exception as e:
        logger.error(f"Unexpected error during webhook deletion: {e}", exc_info=True)
    await asyncio.sleep(2)

def main() -> None:
    logger.info("Starting bot application setup...")
    persistence = PicklePersistence(filepath=config.PERSISTENCE_FILEPATH)
    application = (
        ApplicationBuilder()
        .token(config.BOT_TOKEN)
        .post_init(post_initialization)
        .persistence(persistence)
        .build()
    )
    application.add_handler(CommandHandler("start", start_command))
    application.add_handler(CallbackQueryHandler(button_callback))
    application.add_handler(MessageHandler(filters.PHOTO & ~filters.COMMAND, photo_handler))
    application.add_error_handler(error_handler)
    
    logger.info("Bot starting to poll for updates...")
    application.run_polling(
        allowed_updates=Update.ALL_TYPES,
        drop_pending_updates=True
    )
    logger.info("Bot application has stopped.")

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        logger.critical(f"Critical error during bot startup: {e}", exc_info=True)
        sys.exit(1)
